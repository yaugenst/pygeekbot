{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pygeekbot","text":"<p>Python SDK for Geekbot API</p>"},{"location":"reference/api/","title":"API","text":""},{"location":"reference/api/#pygeekbot.api","title":"<code>pygeekbot.api</code>","text":"<p>Direct implementation of the Geekbot API endpoints.</p>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient","title":"<code>GeekbotApiClient</code>","text":"<p>Async client for the Geekbot API.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>class GeekbotApiClient:\n    \"\"\"Async client for the Geekbot API.\"\"\"\n\n    BASE_URL = \"https://api.geekbot.com/v1\"\n\n    def __init__(self, api_key: str, rate_limit: int = 60):\n        \"\"\"Initialize the client with an API key.\"\"\"\n        self.api_key = api_key\n        auth_header = api_key if api_key.startswith(\"api_\") else f\"Bearer {api_key}\"\n        self.headers = {\n            \"Authorization\": auth_header,\n            \"Content-Type\": \"application/json\",\n        }\n        self.client = httpx.AsyncClient(\n            base_url=self.BASE_URL,\n            headers=self.headers,\n        )\n        self.logger = logging.getLogger(\"geekbot.api\")\n        self._rate_limit = rate_limit  # requests per minute\n        self._request_times: Deque[datetime] = deque(maxlen=rate_limit)\n        self._rate_limit_lock = asyncio.Lock()\n\n    def _handle_errors(self, response: httpx.Response) -&gt; None:\n        \"\"\"Handle common API errors.\"\"\"\n        try:\n            response.raise_for_status()\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 401:\n                raise GeekbotAuthError(e.response.status_code, str(e))\n            elif e.response.status_code == 404:\n                raise GeekbotNotFoundError(e.response.status_code, str(e))\n            elif e.response.status_code == 422:\n                raise GeekbotValidationError(e.response.status_code, str(e))\n            elif e.response.status_code == 429:\n                raise GeekbotRateLimitError(e.response.status_code, str(e))\n            elif e.response.status_code &gt;= 500:\n                raise GeekbotServerError(e.response.status_code, str(e))\n            else:\n                raise GeekbotAPIError(e.response.status_code, str(e))\n\n    def _encode_json(self, data: Any) -&gt; bytes:\n        \"\"\"Encode data to JSON bytes.\"\"\"\n        return msgspec.json.encode(data)\n\n    def _decode_json(self, content: bytes, type: type) -&gt; Any:\n        \"\"\"Decode JSON bytes to specified type.\"\"\"\n        return msgspec.json.decode(content, type=type)\n\n    async def get_standups(self) -&gt; List[Standup]:\n        \"\"\"Get all standups.\"\"\"\n        try:\n            response = await self._make_request(\"GET\", \"/standups\")\n            return self._decode_json(response.content, type=List[Standup])\n        except Exception as e:\n            self.logger.error(f\"Unexpected error fetching standups: {e}\")\n            raise\n\n    async def get_standup(self, standup_id: int) -&gt; Standup:\n        \"\"\"Get a specific standup by ID.\"\"\"\n        try:\n            response = await self._make_request(\"GET\", f\"/standups/{standup_id}\")\n            return self._decode_json(response.content, type=Standup)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error fetching standup {standup_id}: {e}\")\n            raise\n\n    async def create_standup(self, standup: StandupCreate) -&gt; Standup:\n        \"\"\"Creates a new standup.\"\"\"\n        self.logger.debug(f\"Creating new standup with name: {standup.name}\")\n        try:\n            response = await self._make_request(\n                \"POST\",\n                \"/standups\",\n                content=self._encode_json(standup),\n            )\n            return self._decode_json(response.content, type=Standup)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error creating standup: {e}\")\n            raise\n\n    async def update_standup(self, standup_id: int, update: StandupUpdate) -&gt; Standup:\n        \"\"\"Update an existing standup.\n\n        Parameters\n        ----------\n        standup_id : int\n            ID of the standup to update\n        update : StandupUpdate\n            The update configuration\n\n        Returns\n        -------\n        Standup\n            The updated standup details\n        \"\"\"\n        try:\n            response = await self._make_request(\n                \"PATCH\",\n                f\"/standups/{standup_id}\",\n                content=self._encode_json(update),\n            )\n            return self._decode_json(response.content, type=Standup)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error updating standup {standup_id}: {e}\")\n            raise\n\n    async def delete_standup(self, standup_id: int) -&gt; None:\n        \"\"\"Delete a standup.\"\"\"\n        try:\n            await self._make_request(\"DELETE\", f\"/standups/{standup_id}\")\n        except Exception as e:\n            self.logger.error(f\"Unexpected error deleting standup {standup_id}: {e}\")\n            raise\n\n    async def get_reports(\n        self,\n        standup_id: Optional[int] = None,\n        limit: Optional[int] = None,\n        user_id: Optional[int] = None,\n        after: Optional[int] = None,\n        before: Optional[int] = None,\n        question_ids: Optional[List[int]] = None,\n        html: Optional[bool] = None,\n    ) -&gt; List[StandupReport]:\n        \"\"\"Get standup reports with optional filters.\"\"\"\n        params = {}\n        if standup_id is not None:\n            params[\"standup_id\"] = standup_id\n        if limit is not None:\n            params[\"limit\"] = limit\n        if user_id is not None:\n            params[\"user_id\"] = user_id\n        if after is not None:\n            params[\"after\"] = after\n        if before is not None:\n            params[\"before\"] = before\n        if question_ids is not None:\n            params[\"question_ids\"] = question_ids\n        if html is not None:\n            params[\"html\"] = html\n\n        try:\n            response = await self._make_request(\"GET\", \"/reports\", params=params)\n            return self._decode_json(response.content, type=List[StandupReport])\n        except Exception as e:\n            self.logger.error(f\"Unexpected error fetching reports: {e}\")\n            raise\n\n    async def get_report(self, report_id: int) -&gt; StandupReport:\n        \"\"\"Get a specific report by ID.\"\"\"\n        try:\n            response = await self._make_request(\"GET\", f\"/reports/{report_id}\")\n            return self._decode_json(response.content, type=StandupReport)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error fetching report {report_id}: {e}\")\n            raise\n\n    async def create_report(self, report: ReportCreate) -&gt; StandupReport:\n        \"\"\"Create a new report.\n\n        Parameters\n        ----------\n        report : ReportCreate\n            The report configuration to create\n\n        Returns\n        -------\n        StandupReport\n            The created report details\n        \"\"\"\n        try:\n            response = await self._make_request(\n                \"POST\",\n                \"/reports\",\n                content=self._encode_json(report),\n            )\n            return self._decode_json(response.content, type=StandupReport)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error creating report: {e}\")\n            raise\n\n    async def get_team(self) -&gt; Team:\n        \"\"\"Get team information.\"\"\"\n        try:\n            response = await self._make_request(\"GET\", \"/teams\")\n            return self._decode_json(response.content, type=Team)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error fetching team information: {e}\")\n            raise\n\n    async def duplicate_standup(\n        self,\n        standup_id: int,\n        name: str,\n        channel: Optional[str] = None,\n        time: Optional[str] = None,\n        timezone: Optional[str] = None,\n        wait_time: Optional[int] = None,\n        days: Optional[List[str]] = None,\n        questions: Optional[List[Dict[str, str]]] = None,\n        users: Optional[List[int]] = None,\n        sync_channel_members: Optional[bool] = None,\n        personalised: Optional[bool] = None,\n    ) -&gt; Standup:\n        \"\"\"Duplicate an existing standup with optional modifications.\"\"\"\n        data = {\n            \"name\": name,  # Required parameter\n        }\n        # Add optional parameters only if they are provided\n        if channel is not None:\n            data[\"channel\"] = channel\n        if time is not None:\n            data[\"time\"] = time\n        if timezone is not None:\n            data[\"timezone\"] = timezone\n        if wait_time is not None:\n            data[\"wait_time\"] = wait_time\n        if days is not None:\n            data[\"days\"] = days\n        if questions is not None:\n            data[\"questions\"] = questions\n        if users is not None:\n            data[\"users\"] = users\n        if sync_channel_members is not None:\n            data[\"sync_channel_members\"] = sync_channel_members\n        if personalised is not None:\n            data[\"personalised\"] = personalised\n\n        try:\n            response = await self._make_request(\n                \"POST\",\n                f\"/standups/{standup_id}/duplicate\",\n                content=self._encode_json(data),\n            )\n            return self._decode_json(response.content, type=Standup)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error duplicating standup {standup_id}: {e}\")\n            raise\n\n    async def start_standup(\n        self,\n        standup_id: int,\n        user_ids: Optional[List[int]] = None,\n        emails: Optional[List[str]] = None,\n    ) -&gt; str:\n        \"\"\"Start a standup for specific users.\n\n        Returns\n        -------\n        str\n            Response message from the API, usually \"ok\"\n        \"\"\"\n        data = {}\n        if user_ids:\n            data[\"user_ids\"] = user_ids\n        if emails:\n            data[\"emails\"] = emails\n\n        try:\n            response = await self._make_request(\n                \"POST\",\n                f\"/standups/{standup_id}/start\",\n                content=self._encode_json(data),\n            )\n            # The API returns a simple string, not a JSON object\n            return response.content.decode(\"utf-8\").strip('\"')\n        except Exception as e:\n            self.logger.error(f\"Unexpected error starting standup {standup_id}: {e}\")\n            raise\n\n    async def replace_standup(self, standup_id: int, standup: StandupCreate) -&gt; Standup:\n        \"\"\"Replace an existing standup.\n\n        Parameters\n        ----------\n        standup_id : int\n            ID of the standup to replace\n        standup : StandupCreate\n            The new standup configuration\n\n        Returns\n        -------\n        Standup\n            The replaced standup details\n        \"\"\"\n        try:\n            response = await self._make_request(\n                \"PUT\",\n                f\"/standups/{standup_id}\",\n                content=self._encode_json(standup),\n            )\n            return self._decode_json(response.content, type=Standup)\n        except Exception as e:\n            self.logger.error(f\"Unexpected error replacing standup {standup_id}: {e}\")\n            raise\n\n    def set_log_level(self, level: int) -&gt; None:\n        \"\"\"Set the logging level for the client.\"\"\"\n        self.logger.setLevel(level)\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the HTTP client.\"\"\"\n        await self.client.aclose()\n\n    async def __aenter__(self) -&gt; \"GeekbotApiClient\":\n        \"\"\"Async context manager entry.\"\"\"\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n        \"\"\"Async context manager exit.\"\"\"\n        await self.close()\n\n    async def _wait_for_rate_limit(self):\n        \"\"\"Wait if necessary to respect rate limits.\n\n        Uses a token bucket style rate limiter with a sliding window.\n        \"\"\"\n        async with self._rate_limit_lock:\n            now = datetime.now()\n            window_start = now - timedelta(minutes=1)\n\n            # Remove requests older than 1 minute\n            while self._request_times and self._request_times[0] &lt; window_start:\n                self._request_times.popleft()\n\n            if len(self._request_times) &gt;= self._rate_limit:\n                # Calculate wait time based on oldest request\n                wait_time = 60 - (now - self._request_times[0]).total_seconds()\n                if wait_time &gt; 0:\n                    self.logger.debug(\n                        f\"Rate limit reached, waiting {wait_time:.2f} seconds\"\n                    )\n                    await asyncio.sleep(wait_time)\n\n            # Add current request time\n            self._request_times.append(now)\n\n    @backoff.on_exception(\n        backoff.expo,\n        (GeekbotServerError, httpx.TransportError, GeekbotRateLimitError),\n        max_tries=3,\n        giveup=lambda e: isinstance(e, GeekbotAuthError),\n    )\n    async def _make_request(self, method: str, url: str, **kwargs) -&gt; httpx.Response:\n        \"\"\"Make an HTTP request with retry logic and rate limiting.\n\n        Parameters\n        ----------\n        method : str\n            HTTP method (GET, POST, etc.)\n        url : str\n            API endpoint URL\n        **kwargs : dict\n            Additional arguments to pass to httpx.request\n\n        Returns\n        -------\n        httpx.Response\n            The API response\n\n        Raises\n        ------\n        GeekbotAPIError\n            If the request fails after retries\n        \"\"\"\n        await self._wait_for_rate_limit()\n\n        try:\n            response = await self.client.request(method, url, **kwargs)\n            self._handle_errors(response)\n            return response\n        except httpx.HTTPStatusError as e:\n            if e.response.status_code == 429:  # Rate limit error\n                self.logger.warning(\"Rate limit exceeded, backing off...\")\n                raise GeekbotRateLimitError(e.response.status_code, str(e))\n            raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.__aenter__","title":"<code>__aenter__()</code>  <code>async</code>","text":"<p>Async context manager entry.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def __aenter__(self) -&gt; \"GeekbotApiClient\":\n    \"\"\"Async context manager entry.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.__aexit__","title":"<code>__aexit__(exc_type, exc_val, exc_tb)</code>  <code>async</code>","text":"<p>Async context manager exit.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def __aexit__(self, exc_type, exc_val, exc_tb) -&gt; None:\n    \"\"\"Async context manager exit.\"\"\"\n    await self.close()\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.__init__","title":"<code>__init__(api_key, rate_limit=60)</code>","text":"<p>Initialize the client with an API key.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>def __init__(self, api_key: str, rate_limit: int = 60):\n    \"\"\"Initialize the client with an API key.\"\"\"\n    self.api_key = api_key\n    auth_header = api_key if api_key.startswith(\"api_\") else f\"Bearer {api_key}\"\n    self.headers = {\n        \"Authorization\": auth_header,\n        \"Content-Type\": \"application/json\",\n    }\n    self.client = httpx.AsyncClient(\n        base_url=self.BASE_URL,\n        headers=self.headers,\n    )\n    self.logger = logging.getLogger(\"geekbot.api\")\n    self._rate_limit = rate_limit  # requests per minute\n    self._request_times: Deque[datetime] = deque(maxlen=rate_limit)\n    self._rate_limit_lock = asyncio.Lock()\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the HTTP client.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the HTTP client.\"\"\"\n    await self.client.aclose()\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.create_report","title":"<code>create_report(report)</code>  <code>async</code>","text":"<p>Create a new report.</p> <p>Parameters:</p> Name Type Description Default <code>report</code> <code>ReportCreate</code> <p>The report configuration to create</p> required <p>Returns:</p> Type Description <code>StandupReport</code> <p>The created report details</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def create_report(self, report: ReportCreate) -&gt; StandupReport:\n    \"\"\"Create a new report.\n\n    Parameters\n    ----------\n    report : ReportCreate\n        The report configuration to create\n\n    Returns\n    -------\n    StandupReport\n        The created report details\n    \"\"\"\n    try:\n        response = await self._make_request(\n            \"POST\",\n            \"/reports\",\n            content=self._encode_json(report),\n        )\n        return self._decode_json(response.content, type=StandupReport)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error creating report: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.create_standup","title":"<code>create_standup(standup)</code>  <code>async</code>","text":"<p>Creates a new standup.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def create_standup(self, standup: StandupCreate) -&gt; Standup:\n    \"\"\"Creates a new standup.\"\"\"\n    self.logger.debug(f\"Creating new standup with name: {standup.name}\")\n    try:\n        response = await self._make_request(\n            \"POST\",\n            \"/standups\",\n            content=self._encode_json(standup),\n        )\n        return self._decode_json(response.content, type=Standup)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error creating standup: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.delete_standup","title":"<code>delete_standup(standup_id)</code>  <code>async</code>","text":"<p>Delete a standup.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def delete_standup(self, standup_id: int) -&gt; None:\n    \"\"\"Delete a standup.\"\"\"\n    try:\n        await self._make_request(\"DELETE\", f\"/standups/{standup_id}\")\n    except Exception as e:\n        self.logger.error(f\"Unexpected error deleting standup {standup_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.duplicate_standup","title":"<code>duplicate_standup(standup_id, name, channel=None, time=None, timezone=None, wait_time=None, days=None, questions=None, users=None, sync_channel_members=None, personalised=None)</code>  <code>async</code>","text":"<p>Duplicate an existing standup with optional modifications.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def duplicate_standup(\n    self,\n    standup_id: int,\n    name: str,\n    channel: Optional[str] = None,\n    time: Optional[str] = None,\n    timezone: Optional[str] = None,\n    wait_time: Optional[int] = None,\n    days: Optional[List[str]] = None,\n    questions: Optional[List[Dict[str, str]]] = None,\n    users: Optional[List[int]] = None,\n    sync_channel_members: Optional[bool] = None,\n    personalised: Optional[bool] = None,\n) -&gt; Standup:\n    \"\"\"Duplicate an existing standup with optional modifications.\"\"\"\n    data = {\n        \"name\": name,  # Required parameter\n    }\n    # Add optional parameters only if they are provided\n    if channel is not None:\n        data[\"channel\"] = channel\n    if time is not None:\n        data[\"time\"] = time\n    if timezone is not None:\n        data[\"timezone\"] = timezone\n    if wait_time is not None:\n        data[\"wait_time\"] = wait_time\n    if days is not None:\n        data[\"days\"] = days\n    if questions is not None:\n        data[\"questions\"] = questions\n    if users is not None:\n        data[\"users\"] = users\n    if sync_channel_members is not None:\n        data[\"sync_channel_members\"] = sync_channel_members\n    if personalised is not None:\n        data[\"personalised\"] = personalised\n\n    try:\n        response = await self._make_request(\n            \"POST\",\n            f\"/standups/{standup_id}/duplicate\",\n            content=self._encode_json(data),\n        )\n        return self._decode_json(response.content, type=Standup)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error duplicating standup {standup_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.get_report","title":"<code>get_report(report_id)</code>  <code>async</code>","text":"<p>Get a specific report by ID.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def get_report(self, report_id: int) -&gt; StandupReport:\n    \"\"\"Get a specific report by ID.\"\"\"\n    try:\n        response = await self._make_request(\"GET\", f\"/reports/{report_id}\")\n        return self._decode_json(response.content, type=StandupReport)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error fetching report {report_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.get_reports","title":"<code>get_reports(standup_id=None, limit=None, user_id=None, after=None, before=None, question_ids=None, html=None)</code>  <code>async</code>","text":"<p>Get standup reports with optional filters.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def get_reports(\n    self,\n    standup_id: Optional[int] = None,\n    limit: Optional[int] = None,\n    user_id: Optional[int] = None,\n    after: Optional[int] = None,\n    before: Optional[int] = None,\n    question_ids: Optional[List[int]] = None,\n    html: Optional[bool] = None,\n) -&gt; List[StandupReport]:\n    \"\"\"Get standup reports with optional filters.\"\"\"\n    params = {}\n    if standup_id is not None:\n        params[\"standup_id\"] = standup_id\n    if limit is not None:\n        params[\"limit\"] = limit\n    if user_id is not None:\n        params[\"user_id\"] = user_id\n    if after is not None:\n        params[\"after\"] = after\n    if before is not None:\n        params[\"before\"] = before\n    if question_ids is not None:\n        params[\"question_ids\"] = question_ids\n    if html is not None:\n        params[\"html\"] = html\n\n    try:\n        response = await self._make_request(\"GET\", \"/reports\", params=params)\n        return self._decode_json(response.content, type=List[StandupReport])\n    except Exception as e:\n        self.logger.error(f\"Unexpected error fetching reports: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.get_standup","title":"<code>get_standup(standup_id)</code>  <code>async</code>","text":"<p>Get a specific standup by ID.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def get_standup(self, standup_id: int) -&gt; Standup:\n    \"\"\"Get a specific standup by ID.\"\"\"\n    try:\n        response = await self._make_request(\"GET\", f\"/standups/{standup_id}\")\n        return self._decode_json(response.content, type=Standup)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error fetching standup {standup_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.get_standups","title":"<code>get_standups()</code>  <code>async</code>","text":"<p>Get all standups.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def get_standups(self) -&gt; List[Standup]:\n    \"\"\"Get all standups.\"\"\"\n    try:\n        response = await self._make_request(\"GET\", \"/standups\")\n        return self._decode_json(response.content, type=List[Standup])\n    except Exception as e:\n        self.logger.error(f\"Unexpected error fetching standups: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.get_team","title":"<code>get_team()</code>  <code>async</code>","text":"<p>Get team information.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def get_team(self) -&gt; Team:\n    \"\"\"Get team information.\"\"\"\n    try:\n        response = await self._make_request(\"GET\", \"/teams\")\n        return self._decode_json(response.content, type=Team)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error fetching team information: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.replace_standup","title":"<code>replace_standup(standup_id, standup)</code>  <code>async</code>","text":"<p>Replace an existing standup.</p> <p>Parameters:</p> Name Type Description Default <code>standup_id</code> <code>int</code> <p>ID of the standup to replace</p> required <code>standup</code> <code>StandupCreate</code> <p>The new standup configuration</p> required <p>Returns:</p> Type Description <code>Standup</code> <p>The replaced standup details</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def replace_standup(self, standup_id: int, standup: StandupCreate) -&gt; Standup:\n    \"\"\"Replace an existing standup.\n\n    Parameters\n    ----------\n    standup_id : int\n        ID of the standup to replace\n    standup : StandupCreate\n        The new standup configuration\n\n    Returns\n    -------\n    Standup\n        The replaced standup details\n    \"\"\"\n    try:\n        response = await self._make_request(\n            \"PUT\",\n            f\"/standups/{standup_id}\",\n            content=self._encode_json(standup),\n        )\n        return self._decode_json(response.content, type=Standup)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error replacing standup {standup_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.set_log_level","title":"<code>set_log_level(level)</code>","text":"<p>Set the logging level for the client.</p> Source code in <code>pygeekbot/api.py</code> <pre><code>def set_log_level(self, level: int) -&gt; None:\n    \"\"\"Set the logging level for the client.\"\"\"\n    self.logger.setLevel(level)\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.start_standup","title":"<code>start_standup(standup_id, user_ids=None, emails=None)</code>  <code>async</code>","text":"<p>Start a standup for specific users.</p> <p>Returns:</p> Type Description <code>str</code> <p>Response message from the API, usually \"ok\"</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def start_standup(\n    self,\n    standup_id: int,\n    user_ids: Optional[List[int]] = None,\n    emails: Optional[List[str]] = None,\n) -&gt; str:\n    \"\"\"Start a standup for specific users.\n\n    Returns\n    -------\n    str\n        Response message from the API, usually \"ok\"\n    \"\"\"\n    data = {}\n    if user_ids:\n        data[\"user_ids\"] = user_ids\n    if emails:\n        data[\"emails\"] = emails\n\n    try:\n        response = await self._make_request(\n            \"POST\",\n            f\"/standups/{standup_id}/start\",\n            content=self._encode_json(data),\n        )\n        # The API returns a simple string, not a JSON object\n        return response.content.decode(\"utf-8\").strip('\"')\n    except Exception as e:\n        self.logger.error(f\"Unexpected error starting standup {standup_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api/#pygeekbot.api.GeekbotApiClient.update_standup","title":"<code>update_standup(standup_id, update)</code>  <code>async</code>","text":"<p>Update an existing standup.</p> <p>Parameters:</p> Name Type Description Default <code>standup_id</code> <code>int</code> <p>ID of the standup to update</p> required <code>update</code> <code>StandupUpdate</code> <p>The update configuration</p> required <p>Returns:</p> Type Description <code>Standup</code> <p>The updated standup details</p> Source code in <code>pygeekbot/api.py</code> <pre><code>async def update_standup(self, standup_id: int, update: StandupUpdate) -&gt; Standup:\n    \"\"\"Update an existing standup.\n\n    Parameters\n    ----------\n    standup_id : int\n        ID of the standup to update\n    update : StandupUpdate\n        The update configuration\n\n    Returns\n    -------\n    Standup\n        The updated standup details\n    \"\"\"\n    try:\n        response = await self._make_request(\n            \"PATCH\",\n            f\"/standups/{standup_id}\",\n            content=self._encode_json(update),\n        )\n        return self._decode_json(response.content, type=Standup)\n    except Exception as e:\n        self.logger.error(f\"Unexpected error updating standup {standup_id}: {e}\")\n        raise\n</code></pre>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#pygeekbot.client","title":"<code>pygeekbot.client</code>","text":"<p>Geekbot API client.</p>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient","title":"<code>GeekbotClient</code>","text":"<p>Client for interacting with the Geekbot API.</p> <p>This client provides two categories of methods: 1. Official API methods that directly implement the Geekbot API endpoints 2. Extended utility methods that provide additional functionality</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>The Geekbot API key for authentication</p> required Notes <p>Official API documentation: https://geekbot.com/developers/</p> Source code in <code>pygeekbot/client.py</code> <pre><code>class GeekbotClient:\n    \"\"\"\n    Client for interacting with the Geekbot API.\n\n    This client provides two categories of methods:\n    1. Official API methods that directly implement the Geekbot API endpoints\n    2. Extended utility methods that provide additional functionality\n\n    Parameters\n    ----------\n    api_key : str\n        The Geekbot API key for authentication\n\n    Notes\n    -----\n    Official API documentation: https://geekbot.com/developers/\n    \"\"\"\n\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self._loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self._loop)\n        self._async_client = GeekbotClientAsync(api_key)\n        self.client = self._async_client.client\n        self.logger = setup_logger(\"geekbot.client\")\n\n    def __enter__(self):\n        self.logger.debug(\"Entering GeekbotClient context\")\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Clean up resources when exiting context.\"\"\"\n        self.logger.debug(\"Exiting GeekbotClient context\")\n        try:\n            self._loop.run_until_complete(self._async_client.client.aclose())\n        finally:\n            self._loop.close()\n            asyncio.set_event_loop(None)\n\n    def close(self):\n        \"\"\"Close the HTTP client.\"\"\"\n        self._loop.run_until_complete(self._async_client.close())\n        self._loop.close()\n\n    def _run(self, coro):\n        \"\"\"Run a coroutine in the event loop.\"\"\"\n        return self._loop.run_until_complete(coro)\n\n    def get_standups(self) -&gt; List[Standup]:\n        \"\"\"\n        List all standups (Official API endpoint).\n\n        Returns\n        -------\n        List[Standup]\n            List of standup objects\n\n        Notes\n        -----\n        Official API endpoint: GET /v1/standups\n        \"\"\"\n        return self._run(self._async_client.get_standups())\n\n    def get_standup(self, standup_id: int) -&gt; Standup:\n        \"\"\"Get a specific standup by ID.\"\"\"\n        return self._run(self._async_client.get_standup(standup_id))\n\n    def create_standup(self, standup: StandupCreate) -&gt; Standup:\n        \"\"\"Creates a new standup.\"\"\"\n        return self._run(self._async_client.create_standup(standup))\n\n    def update_standup(self, standup_id: int, standup: StandupUpdate) -&gt; Standup:\n        \"\"\"Partially updates a standup.\"\"\"\n        return self._run(self._async_client.update_standup(standup_id, standup))\n\n    def replace_standup(self, standup_id: int, standup: StandupCreate) -&gt; Standup:\n        \"\"\"Fully replaces a standup.\"\"\"\n        return self._run(self._async_client.replace_standup(standup_id, standup))\n\n    def duplicate_standup(\n        self,\n        standup_id: int,\n        name: str,\n        channel: Optional[str] = None,\n        time: Optional[str] = None,\n        timezone: Optional[str] = None,\n        wait_time: Optional[int] = None,\n        days: Optional[List[str]] = None,\n        questions: Optional[List[dict]] = None,\n        users: Optional[List[int]] = None,\n        sync_channel_members: Optional[bool] = None,\n        personalised: Optional[bool] = None,\n    ) -&gt; Standup:\n        \"\"\"Duplicates a standup with optional modifications.\"\"\"\n        return self._run(\n            self._async_client.duplicate_standup(\n                standup_id=standup_id,\n                name=name,\n                channel=channel,\n                time=time,\n                timezone=timezone,\n                wait_time=wait_time,\n                days=days,\n                questions=questions,\n                users=users,\n                sync_channel_members=sync_channel_members,\n                personalised=personalised,\n            )\n        )\n\n    def delete_standup(self, standup_id: int) -&gt; None:\n        \"\"\"Delete a standup.\"\"\"\n        self._run(self._async_client.delete_standup(standup_id))\n\n    def start_standup(\n        self,\n        standup_id: int,\n        user_ids: Optional[List[int]] = None,\n        emails: Optional[List[str]] = None,\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Start a standup for all or specific users.\"\"\"\n        return self._run(\n            self._async_client.start_standup(\n                standup_id=standup_id,\n                user_ids=user_ids,\n                emails=emails,\n            )\n        )\n\n    def get_reports(\n        self,\n        standup_id: Optional[int] = None,\n        limit: Optional[int] = None,\n        user_id: Optional[int] = None,\n        after: Optional[int] = None,\n        before: Optional[int] = None,\n        question_ids: Optional[List[int]] = None,\n        html: Optional[bool] = None,\n    ) -&gt; List[StandupReport]:\n        \"\"\"Get reports, optionally filtered by various parameters.\"\"\"\n        return self._run(\n            self._async_client.get_reports(\n                standup_id=standup_id,\n                limit=limit,\n                user_id=user_id,\n                after=after,\n                before=before,\n                question_ids=question_ids,\n                html=html,\n            )\n        )\n\n    def create_report(self, report: ReportCreate) -&gt; StandupReport:\n        \"\"\"Create a new report.\"\"\"\n        return self._run(self._async_client.create_report(report))\n\n    def get_team(self) -&gt; Team:\n        \"\"\"Get team information.\"\"\"\n        return self._run(self._async_client.get_team())\n\n    # Helper Methods\n    def get_user_reports(\n        self,\n        user_id: int,\n        limit: int = 30,\n        after: Optional[int] = None,\n        before: Optional[int] = None,\n    ) -&gt; List[StandupReport]:\n        \"\"\"Get reports for a specific user.\"\"\"\n        return self._run(\n            self._async_client.get_user_reports(\n                user_id=user_id,\n                limit=limit,\n                after=after,\n                before=before,\n            )\n        )\n\n    def get_standup_reports_since(\n        self,\n        standup_id: int,\n        since_timestamp: int,\n        limit: int = 100,\n    ) -&gt; List[StandupReport]:\n        \"\"\"Get all reports for a standup since a specific time.\"\"\"\n        return self._run(\n            self._async_client.get_standup_reports_since(\n                standup_id=standup_id,\n                since_timestamp=since_timestamp,\n                limit=limit,\n            )\n        )\n\n    def find_standup_by_name(self, name: str) -&gt; Optional[Standup]:\n        \"\"\"Find a standup by its name (case-insensitive).\"\"\"\n        return self._run(self._async_client.find_standup_by_name(name))\n\n    def clone_standup(\n        self,\n        standup_id: int,\n        new_name: str,\n        new_channel: Optional[str] = None,\n    ) -&gt; Standup:\n        \"\"\"Clone a standup with minimal changes.\"\"\"\n        return self._run(\n            self._async_client.clone_standup(\n                standup_id=standup_id,\n                new_name=new_name,\n                new_channel=new_channel,\n            )\n        )\n\n    def pause_standup(self, standup_id: int) -&gt; Standup:\n        \"\"\"Pause a standup by setting wait_time to null.\"\"\"\n        return self._run(self._async_client.pause_standup(standup_id))\n\n    def find_user_by_email(self, email: str) -&gt; Optional[StandupUser]:\n        \"\"\"Find a team member by their email.\"\"\"\n        return self._run(self._async_client.find_user_by_email(email))\n\n    def get_user_standups(self, user_id: int) -&gt; List[Standup]:\n        \"\"\"Get all standups that a user participates in.\"\"\"\n        return self._run(self._async_client.get_user_standups(user_id))\n\n    @staticmethod\n    def format_time(hour: int, minute: int = 0) -&gt; str:\n        \"\"\"Format time in HH:MM:SS format.\"\"\"\n        return GeekbotClientAsync.format_time(hour, minute)\n\n    @staticmethod\n    def weekday_to_str(day: int) -&gt; str:\n        \"\"\"Convert weekday number (0-6) to three-letter format (Mon-Sun).\"\"\"\n        return GeekbotClientAsync.weekday_to_str(day)\n\n    def set_log_level(self, level: int) -&gt; None:\n        \"\"\"Set the logging level for this client.\n\n        Parameters\n        ----------\n        level : int\n            The logging level to set (e.g., logging.DEBUG, logging.INFO)\n        \"\"\"\n        self.logger.setLevel(level)\n        self._async_client.set_log_level(level)\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Clean up resources when exiting context.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Clean up resources when exiting context.\"\"\"\n    self.logger.debug(\"Exiting GeekbotClient context\")\n    try:\n        self._loop.run_until_complete(self._async_client.client.aclose())\n    finally:\n        self._loop.close()\n        asyncio.set_event_loop(None)\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.clone_standup","title":"<code>clone_standup(standup_id, new_name, new_channel=None)</code>","text":"<p>Clone a standup with minimal changes.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def clone_standup(\n    self,\n    standup_id: int,\n    new_name: str,\n    new_channel: Optional[str] = None,\n) -&gt; Standup:\n    \"\"\"Clone a standup with minimal changes.\"\"\"\n    return self._run(\n        self._async_client.clone_standup(\n            standup_id=standup_id,\n            new_name=new_name,\n            new_channel=new_channel,\n        )\n    )\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.close","title":"<code>close()</code>","text":"<p>Close the HTTP client.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def close(self):\n    \"\"\"Close the HTTP client.\"\"\"\n    self._loop.run_until_complete(self._async_client.close())\n    self._loop.close()\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.create_report","title":"<code>create_report(report)</code>","text":"<p>Create a new report.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def create_report(self, report: ReportCreate) -&gt; StandupReport:\n    \"\"\"Create a new report.\"\"\"\n    return self._run(self._async_client.create_report(report))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.create_standup","title":"<code>create_standup(standup)</code>","text":"<p>Creates a new standup.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def create_standup(self, standup: StandupCreate) -&gt; Standup:\n    \"\"\"Creates a new standup.\"\"\"\n    return self._run(self._async_client.create_standup(standup))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.delete_standup","title":"<code>delete_standup(standup_id)</code>","text":"<p>Delete a standup.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def delete_standup(self, standup_id: int) -&gt; None:\n    \"\"\"Delete a standup.\"\"\"\n    self._run(self._async_client.delete_standup(standup_id))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.duplicate_standup","title":"<code>duplicate_standup(standup_id, name, channel=None, time=None, timezone=None, wait_time=None, days=None, questions=None, users=None, sync_channel_members=None, personalised=None)</code>","text":"<p>Duplicates a standup with optional modifications.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def duplicate_standup(\n    self,\n    standup_id: int,\n    name: str,\n    channel: Optional[str] = None,\n    time: Optional[str] = None,\n    timezone: Optional[str] = None,\n    wait_time: Optional[int] = None,\n    days: Optional[List[str]] = None,\n    questions: Optional[List[dict]] = None,\n    users: Optional[List[int]] = None,\n    sync_channel_members: Optional[bool] = None,\n    personalised: Optional[bool] = None,\n) -&gt; Standup:\n    \"\"\"Duplicates a standup with optional modifications.\"\"\"\n    return self._run(\n        self._async_client.duplicate_standup(\n            standup_id=standup_id,\n            name=name,\n            channel=channel,\n            time=time,\n            timezone=timezone,\n            wait_time=wait_time,\n            days=days,\n            questions=questions,\n            users=users,\n            sync_channel_members=sync_channel_members,\n            personalised=personalised,\n        )\n    )\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.find_standup_by_name","title":"<code>find_standup_by_name(name)</code>","text":"<p>Find a standup by its name (case-insensitive).</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def find_standup_by_name(self, name: str) -&gt; Optional[Standup]:\n    \"\"\"Find a standup by its name (case-insensitive).\"\"\"\n    return self._run(self._async_client.find_standup_by_name(name))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.find_user_by_email","title":"<code>find_user_by_email(email)</code>","text":"<p>Find a team member by their email.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def find_user_by_email(self, email: str) -&gt; Optional[StandupUser]:\n    \"\"\"Find a team member by their email.\"\"\"\n    return self._run(self._async_client.find_user_by_email(email))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.format_time","title":"<code>format_time(hour, minute=0)</code>  <code>staticmethod</code>","text":"<p>Format time in HH:MM:SS format.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>@staticmethod\ndef format_time(hour: int, minute: int = 0) -&gt; str:\n    \"\"\"Format time in HH:MM:SS format.\"\"\"\n    return GeekbotClientAsync.format_time(hour, minute)\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_reports","title":"<code>get_reports(standup_id=None, limit=None, user_id=None, after=None, before=None, question_ids=None, html=None)</code>","text":"<p>Get reports, optionally filtered by various parameters.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_reports(\n    self,\n    standup_id: Optional[int] = None,\n    limit: Optional[int] = None,\n    user_id: Optional[int] = None,\n    after: Optional[int] = None,\n    before: Optional[int] = None,\n    question_ids: Optional[List[int]] = None,\n    html: Optional[bool] = None,\n) -&gt; List[StandupReport]:\n    \"\"\"Get reports, optionally filtered by various parameters.\"\"\"\n    return self._run(\n        self._async_client.get_reports(\n            standup_id=standup_id,\n            limit=limit,\n            user_id=user_id,\n            after=after,\n            before=before,\n            question_ids=question_ids,\n            html=html,\n        )\n    )\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_standup","title":"<code>get_standup(standup_id)</code>","text":"<p>Get a specific standup by ID.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_standup(self, standup_id: int) -&gt; Standup:\n    \"\"\"Get a specific standup by ID.\"\"\"\n    return self._run(self._async_client.get_standup(standup_id))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_standup_reports_since","title":"<code>get_standup_reports_since(standup_id, since_timestamp, limit=100)</code>","text":"<p>Get all reports for a standup since a specific time.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_standup_reports_since(\n    self,\n    standup_id: int,\n    since_timestamp: int,\n    limit: int = 100,\n) -&gt; List[StandupReport]:\n    \"\"\"Get all reports for a standup since a specific time.\"\"\"\n    return self._run(\n        self._async_client.get_standup_reports_since(\n            standup_id=standup_id,\n            since_timestamp=since_timestamp,\n            limit=limit,\n        )\n    )\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_standups","title":"<code>get_standups()</code>","text":"<p>List all standups (Official API endpoint).</p> <p>Returns:</p> Type Description <code>List[Standup]</code> <p>List of standup objects</p> Notes <p>Official API endpoint: GET /v1/standups</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_standups(self) -&gt; List[Standup]:\n    \"\"\"\n    List all standups (Official API endpoint).\n\n    Returns\n    -------\n    List[Standup]\n        List of standup objects\n\n    Notes\n    -----\n    Official API endpoint: GET /v1/standups\n    \"\"\"\n    return self._run(self._async_client.get_standups())\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_team","title":"<code>get_team()</code>","text":"<p>Get team information.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_team(self) -&gt; Team:\n    \"\"\"Get team information.\"\"\"\n    return self._run(self._async_client.get_team())\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_user_reports","title":"<code>get_user_reports(user_id, limit=30, after=None, before=None)</code>","text":"<p>Get reports for a specific user.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_user_reports(\n    self,\n    user_id: int,\n    limit: int = 30,\n    after: Optional[int] = None,\n    before: Optional[int] = None,\n) -&gt; List[StandupReport]:\n    \"\"\"Get reports for a specific user.\"\"\"\n    return self._run(\n        self._async_client.get_user_reports(\n            user_id=user_id,\n            limit=limit,\n            after=after,\n            before=before,\n        )\n    )\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.get_user_standups","title":"<code>get_user_standups(user_id)</code>","text":"<p>Get all standups that a user participates in.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def get_user_standups(self, user_id: int) -&gt; List[Standup]:\n    \"\"\"Get all standups that a user participates in.\"\"\"\n    return self._run(self._async_client.get_user_standups(user_id))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.pause_standup","title":"<code>pause_standup(standup_id)</code>","text":"<p>Pause a standup by setting wait_time to null.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def pause_standup(self, standup_id: int) -&gt; Standup:\n    \"\"\"Pause a standup by setting wait_time to null.\"\"\"\n    return self._run(self._async_client.pause_standup(standup_id))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.replace_standup","title":"<code>replace_standup(standup_id, standup)</code>","text":"<p>Fully replaces a standup.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def replace_standup(self, standup_id: int, standup: StandupCreate) -&gt; Standup:\n    \"\"\"Fully replaces a standup.\"\"\"\n    return self._run(self._async_client.replace_standup(standup_id, standup))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.set_log_level","title":"<code>set_log_level(level)</code>","text":"<p>Set the logging level for this client.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The logging level to set (e.g., logging.DEBUG, logging.INFO)</p> required Source code in <code>pygeekbot/client.py</code> <pre><code>def set_log_level(self, level: int) -&gt; None:\n    \"\"\"Set the logging level for this client.\n\n    Parameters\n    ----------\n    level : int\n        The logging level to set (e.g., logging.DEBUG, logging.INFO)\n    \"\"\"\n    self.logger.setLevel(level)\n    self._async_client.set_log_level(level)\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.start_standup","title":"<code>start_standup(standup_id, user_ids=None, emails=None)</code>","text":"<p>Start a standup for all or specific users.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def start_standup(\n    self,\n    standup_id: int,\n    user_ids: Optional[List[int]] = None,\n    emails: Optional[List[str]] = None,\n) -&gt; Dict[str, Any]:\n    \"\"\"Start a standup for all or specific users.\"\"\"\n    return self._run(\n        self._async_client.start_standup(\n            standup_id=standup_id,\n            user_ids=user_ids,\n            emails=emails,\n        )\n    )\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.update_standup","title":"<code>update_standup(standup_id, standup)</code>","text":"<p>Partially updates a standup.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>def update_standup(self, standup_id: int, standup: StandupUpdate) -&gt; Standup:\n    \"\"\"Partially updates a standup.\"\"\"\n    return self._run(self._async_client.update_standup(standup_id, standup))\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClient.weekday_to_str","title":"<code>weekday_to_str(day)</code>  <code>staticmethod</code>","text":"<p>Convert weekday number (0-6) to three-letter format (Mon-Sun).</p> Source code in <code>pygeekbot/client.py</code> <pre><code>@staticmethod\ndef weekday_to_str(day: int) -&gt; str:\n    \"\"\"Convert weekday number (0-6) to three-letter format (Mon-Sun).\"\"\"\n    return GeekbotClientAsync.weekday_to_str(day)\n</code></pre>"},{"location":"reference/client/#pygeekbot.client.GeekbotClientAsync","title":"<code>GeekbotClientAsync</code>","text":"<p>               Bases: <code>GeekbotHelperMixin</code>, <code>GeekbotApiClient</code></p> <p>Async Geekbot client combining API endpoints with helper methods.</p> Source code in <code>pygeekbot/client.py</code> <pre><code>class GeekbotClientAsync(GeekbotHelperMixin, GeekbotApiClient):\n    \"\"\"Async Geekbot client combining API endpoints with helper methods.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#pygeekbot.exceptions","title":"<code>pygeekbot.exceptions</code>","text":""},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotAPIError","title":"<code>GeekbotAPIError</code>","text":"<p>               Bases: <code>GeekbotError</code></p> <p>Raised when the API returns an error.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotAPIError(GeekbotError):\n    \"\"\"Raised when the API returns an error.\"\"\"\n\n    def __init__(self, status_code: int, message: str):\n        self.status_code = status_code\n        self.message = message\n        super().__init__(f\"API Error {status_code}: {message}\")\n</code></pre>"},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotAuthError","title":"<code>GeekbotAuthError</code>","text":"<p>               Bases: <code>GeekbotAPIError</code></p> <p>Raised when authentication fails.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotAuthError(GeekbotAPIError):\n    \"\"\"Raised when authentication fails.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotError","title":"<code>GeekbotError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for Geekbot errors.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotError(Exception):\n    \"\"\"Base exception for Geekbot errors.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotNotFoundError","title":"<code>GeekbotNotFoundError</code>","text":"<p>               Bases: <code>GeekbotAPIError</code></p> <p>Raised when a resource is not found.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotNotFoundError(GeekbotAPIError):\n    \"\"\"Raised when a resource is not found.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotRateLimitError","title":"<code>GeekbotRateLimitError</code>","text":"<p>               Bases: <code>GeekbotAPIError</code></p> <p>Raised when API rate limit is exceeded.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotRateLimitError(GeekbotAPIError):\n    \"\"\"Raised when API rate limit is exceeded.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotServerError","title":"<code>GeekbotServerError</code>","text":"<p>               Bases: <code>GeekbotAPIError</code></p> <p>Raised when server returns 5xx error.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotServerError(GeekbotAPIError):\n    \"\"\"Raised when server returns 5xx error.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/exceptions/#pygeekbot.exceptions.GeekbotValidationError","title":"<code>GeekbotValidationError</code>","text":"<p>               Bases: <code>GeekbotAPIError</code></p> <p>Raised when request validation fails.</p> Source code in <code>pygeekbot/exceptions.py</code> <pre><code>class GeekbotValidationError(GeekbotAPIError):\n    \"\"\"Raised when request validation fails.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/models/#pygeekbot.models","title":"<code>pygeekbot.models</code>","text":""},{"location":"reference/models/#pygeekbot.models.ReportAnswerText","title":"<code>ReportAnswerText</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Text answer to a standup question.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The answer text content</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class ReportAnswerText(msgspec.Struct, kw_only=True):\n    \"\"\"Text answer to a standup question.\n\n    Attributes\n    ----------\n    text : str\n        The answer text content\n    \"\"\"\n\n    text: str\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.ReportCreate","title":"<code>ReportCreate</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Data for creating a new report.</p> <p>Attributes:</p> Name Type Description <code>standup_id</code> <code>int</code> <p>Unique identifier of the standup</p> <code>answers</code> <code>dict[str, dict[str, str]]</code> <p>Mapping of question IDs to answer objects containing text</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class ReportCreate(msgspec.Struct, kw_only=True):\n    \"\"\"Data for creating a new report.\n\n    Attributes\n    ----------\n    standup_id : int\n        Unique identifier of the standup\n    answers : dict[str, dict[str, str]]\n        Mapping of question IDs to answer objects containing text\n    \"\"\"\n\n    standup_id: int\n    answers: Dict[str, Dict[str, str]]  # Format: {\"question_id\": {\"text\": \"answer\"}}\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.ReportMember","title":"<code>ReportMember</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Member who submitted the report.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier of the member</p> <code>username</code> <code>str</code> <p>Slack username of the member</p> <code>realname</code> <code>str</code> <p>Full name of the member</p> <code>profile_img</code> <code>str = None</code> <p>URL to the member's profile image</p> <code>role</code> <code>str = None</code> <p>Role of the member in the team</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class ReportMember(msgspec.Struct, kw_only=True):\n    \"\"\"Member who submitted the report.\n\n    Attributes\n    ----------\n    id : str\n        Unique identifier of the member\n    username : str\n        Slack username of the member\n    realname : str\n        Full name of the member\n    profile_img : str = None\n        URL to the member's profile image\n    role : str = None\n        Role of the member in the team\n    \"\"\"\n\n    id: str\n    username: str\n    realname: str\n    profile_img: Optional[str] = None\n    role: Optional[str] = None\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.ReportQuestion","title":"<code>ReportQuestion</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Question and answer in a report.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier of the question-answer pair</p> <code>question</code> <code>str</code> <p>The text of the question</p> <code>question_id</code> <code>int</code> <p>Reference ID of the original question template</p> <code>color</code> <code>str</code> <p>Color code for UI display</p> <code>answer</code> <code>str</code> <p>The member's answer to the question</p> <code>images</code> <code>list[dict] = []</code> <p>List of image attachments in the answer</p> <code>html_formatted</code> <code>bool = False</code> <p>Whether the answer contains HTML formatting</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class ReportQuestion(msgspec.Struct, kw_only=True):\n    \"\"\"Question and answer in a report.\n\n    Attributes\n    ----------\n    id : int\n        Unique identifier of the question-answer pair\n    question : str\n        The text of the question\n    question_id : int\n        Reference ID of the original question template\n    color : str\n        Color code for UI display\n    answer : str\n        The member's answer to the question\n    images : list[dict] = []\n        List of image attachments in the answer\n    html_formatted : bool = False\n        Whether the answer contains HTML formatting\n    \"\"\"\n\n    id: int\n    question: str\n    question_id: int\n    color: str\n    answer: str\n    images: List[Dict[str, Any]] = []\n    html_formatted: bool = False\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.Standup","title":"<code>Standup</code>","text":"<p>               Bases: <code>Struct</code></p> <p>A standup configuration.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier of the standup</p> <code>name</code> <code>str</code> <p>Name of the standup</p> <code>channel</code> <code>str</code> <p>Slack channel for the standup</p> <code>time</code> <code>str</code> <p>Time of day when the standup occurs (HH:MM:SS format)</p> <code>timezone</code> <code>str</code> <p>Timezone for the standup</p> <code>days</code> <code>list[str]</code> <p>Days of the week when the standup occurs</p> <code>questions</code> <code>list[StandupQuestion]</code> <p>List of questions to ask</p> <code>users</code> <code>list[StandupUser]</code> <p>List of users participating in the standup</p> <code>wait_time</code> <code>int = None</code> <p>Time to wait for responses in minutes. -1 indicates no wait time.</p> <code>personalised</code> <code>bool = False</code> <p>Whether users can change their personal schedule</p> <code>sync_channel_members</code> <code>bool = False</code> <p>Whether to sync with channel membership</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class Standup(msgspec.Struct, kw_only=True):\n    \"\"\"A standup configuration.\n\n    Attributes\n    ----------\n    id : int\n        Unique identifier of the standup\n    name : str\n        Name of the standup\n    channel : str\n        Slack channel for the standup\n    time : str\n        Time of day when the standup occurs (HH:MM:SS format)\n    timezone : str\n        Timezone for the standup\n    days : list[str]\n        Days of the week when the standup occurs\n    questions : list[StandupQuestion]\n        List of questions to ask\n    users : list[StandupUser]\n        List of users participating in the standup\n    wait_time : int = None\n        Time to wait for responses in minutes. -1 indicates no wait time.\n    personalised : bool = False\n        Whether users can change their personal schedule\n    sync_channel_members : bool = False\n        Whether to sync with channel membership\n    \"\"\"\n\n    id: int\n    name: str\n    channel: str\n    time: str\n    timezone: str\n    days: List[str]\n    questions: List[StandupQuestion]\n    users: List[StandupUser]\n    wait_time: Optional[int] = None\n    personalised: bool = False\n    sync_channel_members: bool = False\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.StandupCreate","title":"<code>StandupCreate</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Data for creating a new standup.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the standup</p> <code>channel</code> <code>str</code> <p>Slack channel for the standup</p> <code>time</code> <code>str</code> <p>Time of day when the standup occurs (HH:MM:SS format)</p> <code>timezone</code> <code>str</code> <p>Timezone for the standup</p> <code>days</code> <code>list[str]</code> <p>Days of the week when the standup occurs (3-letter format: Mon, Tue, etc)</p> <code>questions</code> <code>list[dict] = None</code> <p>List of questions to ask, each containing a \"question\" property</p> <code>users</code> <code>list[int]</code> <p>List of user IDs to include</p> <code>wait_time</code> <code>int = None</code> <p>Time to wait for responses in minutes</p> <code>personalised</code> <code>bool = False</code> <p>Whether users can change their personal schedule</p> <code>sync_channel_members</code> <code>bool = False</code> <p>Whether to sync with channel membership</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class StandupCreate(msgspec.Struct, kw_only=True):\n    \"\"\"Data for creating a new standup.\n\n    Attributes\n    ----------\n    name : str\n        Name of the standup\n    channel : str\n        Slack channel for the standup\n    time : str\n        Time of day when the standup occurs (HH:MM:SS format)\n    timezone : str\n        Timezone for the standup\n    days : list[str]\n        Days of the week when the standup occurs (3-letter format: Mon, Tue, etc)\n    questions : list[dict] = None\n        List of questions to ask, each containing a \"question\" property\n    users : list[int]\n        List of user IDs to include\n    wait_time : int = None\n        Time to wait for responses in minutes\n    personalised : bool = False\n        Whether users can change their personal schedule\n    sync_channel_members : bool = False\n        Whether to sync with channel membership\n    \"\"\"\n\n    name: str\n    channel: str\n    time: str\n    timezone: str\n    days: List[str]\n    users: List[int]\n    questions: Optional[List[StandupQuestion]] = None\n    wait_time: Optional[int] = None\n    personalised: bool = False\n    sync_channel_members: bool = False\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.StandupQuestion","title":"<code>StandupQuestion</code>","text":"<p>               Bases: <code>Struct</code></p> <p>A question in a standup.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier of the question</p> <code>text</code> <code>str = None</code> <p>The text of the question</p> <code>color</code> <code>str</code> <p>Color code for UI display</p> <code>schedule</code> <code>str = None</code> <p>Schedule for the question</p> <code>answer_type</code> <code>str = \"text\"</code> <p>Type of answer expected</p> <code>answer_choices</code> <code>list = []</code> <p>List of possible answer choices</p> <code>hasAnswers</code> <code>bool = True</code> <p>Whether the question requires an answer</p> <code>is_random</code> <code>bool = False</code> <p>Whether the question is randomly selected</p> <code>random_texts</code> <code>list = []</code> <p>List of random text variations</p> <code>prefilled_by</code> <code>int = None</code> <p>ID of the question that prefills this one</p> <code>text_id</code> <code>int = None</code> <p>Reference ID for the question text</p> <code>preconditions</code> <code>list = []</code> <p>List of preconditions for the question</p> <code>label</code> <code>str = None</code> <p>Label identifying the question type</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class StandupQuestion(msgspec.Struct, kw_only=True):\n    \"\"\"A question in a standup.\n\n    Attributes\n    ----------\n    id : int\n        Unique identifier of the question\n    text : str = None\n        The text of the question\n    color : str\n        Color code for UI display\n    schedule : str = None\n        Schedule for the question\n    answer_type : str = \"text\"\n        Type of answer expected\n    answer_choices : list = []\n        List of possible answer choices\n    hasAnswers : bool = True\n        Whether the question requires an answer\n    is_random : bool = False\n        Whether the question is randomly selected\n    random_texts : list = []\n        List of random text variations\n    prefilled_by : int = None\n        ID of the question that prefills this one\n    text_id : int = None\n        Reference ID for the question text\n    preconditions : list = []\n        List of preconditions for the question\n    label : str = None\n        Label identifying the question type\n    \"\"\"\n\n    id: int\n    color: str\n    text: Optional[str] = None\n    schedule: Optional[str] = None\n    answer_type: str = \"text\"\n    answer_choices: List[str] = []\n    hasAnswers: bool = True\n    is_random: bool = False\n    random_texts: List[str] = []\n    prefilled_by: Optional[int] = None\n    text_id: Optional[int] = None\n    preconditions: List[Any] = []\n    label: Optional[str] = None\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.StandupReport","title":"<code>StandupReport</code>","text":"<p>               Bases: <code>Struct</code></p> <p>A standup report.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier of the report</p> <code>slack_ts</code> <code>str = None</code> <p>Slack timestamp of the report message</p> <code>standup_id</code> <code>int</code> <p>ID of the standup this report belongs to</p> <code>timestamp</code> <code>int = None</code> <p>Unix timestamp when the report was submitted</p> <code>channel</code> <code>str = None</code> <p>Slack channel where the report was posted</p> <code>member</code> <code>ReportMember = None</code> <p>The member who submitted the report</p> <code>questions</code> <code>list[ReportQuestion] = []</code> <p>List of questions and answers in this report</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class StandupReport(msgspec.Struct, kw_only=True):\n    \"\"\"A standup report.\n\n    Attributes\n    ----------\n    id : int\n        Unique identifier of the report\n    slack_ts : str = None\n        Slack timestamp of the report message\n    standup_id : int\n        ID of the standup this report belongs to\n    timestamp : int = None\n        Unix timestamp when the report was submitted\n    channel : str = None\n        Slack channel where the report was posted\n    member : ReportMember = None\n        The member who submitted the report\n    questions : list[ReportQuestion] = []\n        List of questions and answers in this report\n    \"\"\"\n\n    id: int\n    standup_id: int\n    slack_ts: Optional[str] = None\n    timestamp: Optional[int] = None\n    channel: Optional[str] = None\n    member: Optional[ReportMember] = None\n    questions: List[ReportQuestion] = []\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.StandupStart","title":"<code>StandupStart</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Data for starting a standup.</p> <p>Attributes:</p> Name Type Description <code>users</code> <code>list[int] = None</code> <p>List of user IDs to start the standup for</p> <code>emails</code> <code>list[str] = None</code> <p>List of user emails to start the standup for</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class StandupStart(msgspec.Struct, kw_only=True):\n    \"\"\"Data for starting a standup.\n\n    Attributes\n    ----------\n    users : list[int] = None\n        List of user IDs to start the standup for\n    emails : list[str] = None\n        List of user emails to start the standup for\n    \"\"\"\n\n    users: Optional[List[int]] = None\n    emails: Optional[List[str]] = None\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.StandupUpdate","title":"<code>StandupUpdate</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Data for updating a standup.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str = None</code> <p>New name for the standup</p> <code>channel</code> <code>str = None</code> <p>New Slack channel</p> <code>time</code> <code>str = None</code> <p>New time of day (HH:MM:SS format)</p> <code>timezone</code> <code>str = None</code> <p>New timezone</p> <code>days</code> <code>list[str] = None</code> <p>New days of the week (3-letter format: Mon, Tue, etc)</p> <code>wait_time</code> <code>int = None</code> <p>New wait time in minutes</p> <code>questions</code> <code>list[dict] = None</code> <p>New list of questions, each containing a \"question\" property</p> <code>users</code> <code>list[int] = None</code> <p>New list of user IDs</p> <code>personalised</code> <code>bool = None</code> <p>New personalization setting</p> <code>sync_channel_members</code> <code>bool = None</code> <p>New channel sync setting</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class StandupUpdate(msgspec.Struct, kw_only=True, omit_defaults=True):\n    \"\"\"Data for updating a standup.\n\n    Attributes\n    ----------\n    name : str = None\n        New name for the standup\n    channel : str = None\n        New Slack channel\n    time : str = None\n        New time of day (HH:MM:SS format)\n    timezone : str = None\n        New timezone\n    days : list[str] = None\n        New days of the week (3-letter format: Mon, Tue, etc)\n    wait_time : int = None\n        New wait time in minutes\n    questions : list[dict] = None\n        New list of questions, each containing a \"question\" property\n    users : list[int] = None\n        New list of user IDs\n    personalised : bool = None\n        New personalization setting\n    sync_channel_members : bool = None\n        New channel sync setting\n    \"\"\"\n\n    name: Optional[str] = None\n    channel: Optional[str] = None\n    time: Optional[str] = None\n    timezone: Optional[str] = None\n    days: Optional[List[str]] = None\n    wait_time: Optional[int] = None\n    questions: Optional[List[dict]] = None\n    users: Optional[List[int]] = None\n    personalised: Optional[bool] = None\n    sync_channel_members: Optional[bool] = None\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.StandupUser","title":"<code>StandupUser</code>","text":"<p>               Bases: <code>Struct</code></p> <p>User in a standup.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier of the user</p> <code>username</code> <code>str</code> <p>Slack username of the user</p> <code>realname</code> <code>str</code> <p>Full name of the user</p> <code>profile_img</code> <code>str = None</code> <p>URL to the user's profile image</p> <code>role</code> <code>str = None</code> <p>Role of the user in the team</p> <code>email</code> <code>str = None</code> <p>Email address of the user</p> <code>deleted</code> <code>bool = False</code> <p>Whether the user has been deleted</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class StandupUser(msgspec.Struct, kw_only=True):\n    \"\"\"User in a standup.\n\n    Attributes\n    ----------\n    id : str\n        Unique identifier of the user\n    username : str\n        Slack username of the user\n    realname : str\n        Full name of the user\n    profile_img : str = None\n        URL to the user's profile image\n    role : str = None\n        Role of the user in the team\n    email : str = None\n        Email address of the user\n    deleted : bool = False\n        Whether the user has been deleted\n    \"\"\"\n\n    id: str\n    username: str\n    realname: str\n    profile_img: Optional[str] = None\n    role: Optional[str] = None\n    email: Optional[str] = None\n    deleted: bool = False\n</code></pre>"},{"location":"reference/models/#pygeekbot.models.Team","title":"<code>Team</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Team information.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier of the team</p> <code>name</code> <code>str</code> <p>Name of the team</p> <code>users</code> <code>list[StandupUser]</code> <p>List of users in the team</p> Source code in <code>pygeekbot/models.py</code> <pre><code>class Team(msgspec.Struct, kw_only=True):\n    \"\"\"Team information.\n\n    Attributes\n    ----------\n    id : int\n        Unique identifier of the team\n    name : str\n        Name of the team\n    users : list[StandupUser]\n        List of users in the team\n    \"\"\"\n\n    id: int\n    name: str\n    users: List[StandupUser]\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#pygeekbot.utils","title":"<code>pygeekbot.utils</code>","text":"<p>Utility functions for the Geekbot client.</p>"},{"location":"reference/utils/#pygeekbot.utils.log_response","title":"<code>log_response(endpoint, data, raw_content=None)</code>","text":"<p>Log API response data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Name of the API endpoint (used in filename)</p> required <code>data</code> <code>Any</code> <p>Response data to log</p> required <code>raw_content</code> <code>bytes = None</code> <p>Raw response content to log in a separate file</p> <code>None</code> Source code in <code>pygeekbot/utils.py</code> <pre><code>def log_response(endpoint: str, data: Any, raw_content: bytes = None) -&gt; None:\n    \"\"\"Log API response data to a file.\n\n    Parameters\n    ----------\n    endpoint : str\n        Name of the API endpoint (used in filename)\n    data : Any\n        Response data to log\n    raw_content : bytes = None\n        Raw response content to log in a separate file\n    \"\"\"\n    # Create responses directory if it doesn't exist\n    response_dir = Path(\"responses\")\n    response_dir.mkdir(exist_ok=True)\n\n    # Create filename with timestamp\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n\n    # Write processed response data\n    filename = response_dir / f\"{endpoint}_{timestamp}.json\"\n    with open(filename, \"w\") as f:\n        json.dump(data, f, indent=2, default=str)\n\n    # Write raw response if provided\n    if raw_content is not None:\n        raw_filename = response_dir / f\"{endpoint}_{timestamp}_raw.txt\"\n        with open(raw_filename, \"wb\") as f:\n            f.write(raw_content)\n</code></pre>"}]}